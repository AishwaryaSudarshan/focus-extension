<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Word List</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    ul { font-size: 1.2em; }
    #controls { margin-bottom: 12px; }
    #controls > * { margin-right: 8px; vertical-align: middle; }
  </style>
</head>
<body>
  <h2>Word List</h2>

  <div id="controls">
    <label><input type="checkbox" id="extension-toggle"> Extension On</label>
    <button id="test-notif">Send Test Notification</button>
  </div>

  <ul>
    <li>CAT</li>
    <li>DOG</li>
    <li>BIRD</li>
    <li>FISH</li>
  </ul>
  <a href="wordsearch.html">Back to Word Search</a>

  <script>
    // small shared behavior: toggle mirrors the same localStorage flag and releases cached notifications
    const TOGGLE_KEY = 'focusExtensionEnabled';
    const CACHE_KEY = 'focusExtensionCachedNotifications';
    const INSTANCES_KEY = 'focusExtensionInstances'; // tracks open focus-page instances across tabs
    const RELEASE_DELAY = 500; // ms - short debounce so switching between focus pages won't release
    let instanceId = String(Date.now()) + '-' + Math.random().toString(36).slice(2);
    let releaseTimer = null;
    let isRegisteredInstance = false;
    const toggleEl = document.getElementById('extension-toggle');
    const testBtn = document.getElementById('test-notif');

    function isExtensionEnabled() {
      return localStorage.getItem(TOGGLE_KEY) === 'true';
    }
    function setExtensionEnabled(v) {
      localStorage.setItem(TOGGLE_KEY, v ? 'true' : 'false');
      toggleEl.checked = !!v;
    }

    toggleEl.checked = isExtensionEnabled();
    toggleEl.addEventListener('change', () => {
      setExtensionEnabled(toggleEl.checked);
      if (toggleEl.checked && Notification.permission === 'default') {
        Notification.requestPermission();
      }
    });

    function dispatchAndShow(detail) {
      window.dispatchEvent(new CustomEvent('notify-extension', { detail }));
      if (Notification.permission === 'granted') {
        try {
          new Notification(detail.title, { body: detail.message, icon: detail.iconUrl });
        } catch (e) {
          console.warn('Notification failed', e);
        }
      }
    }

    function isOnFocusSite() {
      return location.pathname.endsWith('wordsearch.html') ||
             location.pathname.endsWith('wordlist.html');
    }

    function cacheNotification(detail) {
      const arr = JSON.parse(localStorage.getItem(CACHE_KEY) || '[]');
      arr.push({ detail, ts: Date.now() });
      localStorage.setItem(CACHE_KEY, JSON.stringify(arr));
      console.log('Notification cached', detail.title);
    }

    // --- focus-instance coordination (so switching between focus pages doesn't release) ---
    function readInstances() {
      try { return JSON.parse(localStorage.getItem(INSTANCES_KEY) || '[]'); } catch (e) { return []; }
    }
    function writeInstances(arr) {
      localStorage.setItem(INSTANCES_KEY, JSON.stringify(arr));
    }
    function anyInstanceVisible(instances) {
      return (instances || readInstances()).some(i => i.visible);
    }
    function registerInstance() {
      const instances = readInstances().filter(i => i && i.id !== instanceId);
      instances.push({ id: instanceId, visible: document.visibilityState === 'visible', ts: Date.now() });
      writeInstances(instances);
      isRegisteredInstance = true;
      // cancel any pending release if another instance is visible
      if (anyInstanceVisible(instances)) cancelScheduledRelease();
    }
    function updateInstanceVisibility(visible) {
      const instances = readInstances().filter(Boolean);
      const idx = instances.findIndex(i => i.id === instanceId);
      if (idx >= 0) {
        instances[idx].visible = !!visible;
        instances[idx].ts = Date.now();
      } else {
        instances.push({ id: instanceId, visible: !!visible, ts: Date.now() });
        isRegisteredInstance = true;
      }
      writeInstances(instances);
      if (!anyInstanceVisible(instances)) scheduleReleaseIfNoVisible();
      else cancelScheduledRelease();
    }
    function removeInstance() {
      const instances = readInstances().filter(i => i.id !== instanceId);
      writeInstances(instances);
      if (!anyInstanceVisible(instances)) scheduleReleaseIfNoVisible();
    }
    function scheduleReleaseIfNoVisible() {
      cancelScheduledRelease();
      const instances = readInstances();
      if (anyInstanceVisible(instances)) return;
      releaseTimer = setTimeout(() => {
        const current = readInstances();
        if (!anyInstanceVisible(current)) {
          try { releaseCachedNotifications(); } catch (e) { console.warn(e); }
        }
        releaseTimer = null;
      }, RELEASE_DELAY);
    }
    function cancelScheduledRelease() {
      if (releaseTimer) {
        clearTimeout(releaseTimer);
        releaseTimer = null;
      }
    }

    function queueOrSendNotification(detail) {
      // If extension is disabled, show immediately
      if (!isExtensionEnabled()) {
        dispatchAndShow(detail);
        return;
      }
      // If user is on the focus pages and visible, cache every notification
      if (isOnFocusSite() && document.visibilityState === 'visible') {
        cacheNotification(detail);
      } else {
        dispatchAndShow(detail);
      }
    }

    function releaseCachedNotifications() {
      const arr = JSON.parse(localStorage.getItem(CACHE_KEY) || '[]');
      if (!arr || arr.length === 0) return;
      // remove cache first, then dispatch all cached notifications
      localStorage.removeItem(CACHE_KEY);
      // stagger notifications so they appear separately to the user
      arr.forEach((item, i) => {
        setTimeout(() => {
          try {
            dispatchAndShow(item.detail);
          } catch (e) {
            console.warn('Failed to dispatch cached notification', e);
          }
        }, i * 200);
      });
    }

    // When user leaves the wordlist tab, release cached notifications
    // document.addEventListener('visibilitychange', () => {
    //   if (document.visibilityState === 'hidden') {
    //     releaseCachedNotifications();
    //   }
    // });
    // coordinate release across focus pages
    window.addEventListener('storage', (ev) => {
      if (ev.key === INSTANCES_KEY) {
        const instances = readInstances();
        if (anyInstanceVisible(instances)) {
          cancelScheduledRelease();
        } else {
          scheduleReleaseIfNoVisible();
        }
      }
    });

    // register this instance if we're on a focus page
    if (isOnFocusSite()) registerInstance();
    // update visibility changes for this instance
    document.addEventListener('visibilitychange', () => {
      if (!isRegisteredInstance && isOnFocusSite()) registerInstance();
      if (isRegisteredInstance) updateInstanceVisibility(document.visibilityState === 'visible');
    });
    // remove instance on unload
    window.addEventListener('beforeunload', () => {
      if (isRegisteredInstance) removeInstance();
    });

    testBtn.addEventListener('click', () => {
      const detail = {
        type: 'basic',
        iconUrl: 'extension/icon16.png',
        title: 'Test Notification',
        message: 'This is a test.'
      };
      if (Notification.permission === 'default') {
        Notification.requestPermission().then(() => {
          queueOrSendNotification(detail);
        });
      } else {
        queueOrSendNotification(detail);
      }
    });
  </script>
</body>
</html>