<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Word Search Game</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #stopwatch { font-size: 1.2em; margin-bottom: 10px; }
    #grid { display: grid; grid-template-columns: repeat(8, 30px); gap: 2px; }
    .cell {
      width: 30px; height: 30px; text-align: center; vertical-align: middle;
      border: 1px solid #ccc; font-size: 18px; cursor: pointer; background: #fff;
      user-select: none;
    }
    .cell.selected { background: #b3e5fc; }
    .cell.found { background: #a5d6a7; }
    #message { margin-top: 10px; }
    #word-list-link { margin-bottom: 15px; display: inline-block; }
    #controls { margin-bottom: 12px; }
    #controls > * { margin-right: 8px; vertical-align: middle; }
  </style>
</head>
<body>
  <h2>Word Search</h2>
  <div id="controls">
    <a id="word-list-link" href="wordlist.html" target="_blank">See Word List</a>

    <!-- extension toggle and test button -->
    <label><input type="checkbox" id="extension-toggle"> Extension On</label>
    <button id="test-notif">Send Test Notification</button>
  </div>

  <div id="stopwatch">Time: <span id="timer">00:00</span></div>
  <div id="grid"></div>
  <div id="message"></div>
  <script>
    // Word search data
    const words = ['CAT', 'DOG', 'BIRD', 'FISH'];
    const gridData = [
      ['C','A','T','X','D','O','G','Y'],
      ['B','I','R','D','Z','F','I','S'],
      ['H','A','T','S','H','E','E','P'],
      ['M','O','U','S','E','L','I','O'],
      ['P','I','G','C','O','W','H','E'],
      ['R','A','B','B','I','T','S','Q'],
      ['U','N','I','C','O','R','N','S'],
      ['F','O','X','E','S','L','A','M']
    ];

    // Render grid
    const gridDiv = document.getElementById('grid');
    let selectedCells = [];
    let foundWords = new Set();

    for (let row = 0; row < gridData.length; row++) {
      for (let col = 0; col < gridData[row].length; col++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.textContent = gridData[row][col];
        cell.dataset.row = row;
        cell.dataset.col = col;
        cell.addEventListener('click', () => handleCellClick(cell));
        gridDiv.appendChild(cell);
      }
    }

    function handleCellClick(cell) {
      if (cell.classList.contains('found')) return;
      cell.classList.toggle('selected');
      if (cell.classList.contains('selected')) {
        selectedCells.push(cell);
      } else {
        selectedCells = selectedCells.filter(c => c !== cell);
      }
      checkSelection();
    }

    function checkSelection() {
      const selectedWord = selectedCells.map(c => c.textContent).join('');
      const reversedWord = selectedCells.map(c => c.textContent).reverse().join('');
      if (words.includes(selectedWord)) {
        markFound(selectedWord);
      } else if (words.includes(reversedWord)) {
        markFound(reversedWord);
      }
    }

    function markFound(word) {
      selectedCells.forEach(cell => {
        cell.classList.remove('selected');
        cell.classList.add('found');
      });
      foundWords.add(word);
      selectedCells = [];
      if (foundWords.size === words.length) {
        document.getElementById('message').textContent = 'Congratulations! You found all the words!';
        stopStopwatch();
      }
    }

    // Stopwatch logic with scheduled notifications
    let startTime, timerInterval;
    const notificationTimes = [5, 10, 15, 20, 25, 30, 35, 40, 60]; // seconds (changed per request)
    let notifiedAt = new Set();

    // Extension toggle + caching behavior
    const TOGGLE_KEY = 'focusExtensionEnabled';
    const CACHE_KEY = 'focusExtensionCachedNotifications';
    const INSTANCES_KEY = 'focusExtensionInstances';
    const RELEASE_DELAY = 500;
    let instanceId = String(Date.now()) + '-' + Math.random().toString(36).slice(2);
    let releaseTimer = null;
    let isRegisteredInstance = false;

    const toggleEl = document.getElementById('extension-toggle');
    const testBtn = document.getElementById('test-notif');

    function isExtensionEnabled() {
      return localStorage.getItem(TOGGLE_KEY) === 'true';
    }
    function setExtensionEnabled(v) {
      localStorage.setItem(TOGGLE_KEY, v ? 'true' : 'false');
      toggleEl.checked = !!v;
    }

    // initialize toggle from storage
    toggleEl.checked = isExtensionEnabled();
    toggleEl.addEventListener('change', () => {
      setExtensionEnabled(toggleEl.checked);
      // request permission when enabling
      if (toggleEl.checked && Notification.permission === 'default') {
        Notification.requestPermission();
      }
    });

    function dispatchAndShow(detail) {
      // dispatch the same custom event shape used by extension test
      window.dispatchEvent(new CustomEvent('notify-extension', { detail }));

      // show native browser notification as the extension would
      if (Notification.permission === 'granted') {
        try {
          new Notification(detail.title, { body: detail.message, icon: detail.iconUrl });
        } catch (e) {
          console.warn('Notification failed', e);
        }
      }
    }

    function cacheNotification(detail) {
      // push every notification into the cache so multiple notifications are stored
      const arr = JSON.parse(localStorage.getItem(CACHE_KEY) || '[]');
      arr.push({ detail, ts: Date.now() });
      localStorage.setItem(CACHE_KEY, JSON.stringify(arr));
      console.log('Notification cached', detail.title);
    }

    // helpers that were missing and block execution if absent
    function isOnFocusSite() {
      return location.pathname.endsWith('wordsearch.html') ||
             location.pathname.endsWith('wordlist.html');
    }

    function queueOrSendNotification(detail) {
      // If extension is disabled, show immediately
      if (!isExtensionEnabled()) {
        dispatchAndShow(detail);
        return;
      }
      // If user is on focus pages and visible, cache; otherwise show immediately
      if (isOnFocusSite() && document.visibilityState === 'visible') {
        cacheNotification(detail);
      } else {
        dispatchAndShow(detail);
      }
    }

    // --- cross-tab focus-instance coordination (so switching focus pages doesn't release) ---
    function readInstances() {
      try { return JSON.parse(localStorage.getItem(INSTANCES_KEY) || '[]'); } catch (e) { return []; }
    }
    function writeInstances(arr) {
      localStorage.setItem(INSTANCES_KEY, JSON.stringify(arr));
    }
    function anyInstanceVisible(instances) {
      return (instances || readInstances()).some(i => i.visible);
    }
    function registerInstance() {
      const instances = readInstances().filter(i => i && i.id !== instanceId);
      instances.push({ id: instanceId, visible: document.visibilityState === 'visible', ts: Date.now() });
      writeInstances(instances);
      isRegisteredInstance = true;
      if (anyInstanceVisible(instances)) cancelScheduledRelease();
    }
    function updateInstanceVisibility(visible) {
      const instances = readInstances().filter(Boolean);
      const idx = instances.findIndex(i => i.id === instanceId);
      if (idx >= 0) {
        instances[idx].visible = !!visible;
        instances[idx].ts = Date.now();
      } else {
        instances.push({ id: instanceId, visible: !!visible, ts: Date.now() });
        isRegisteredInstance = true;
      }
      writeInstances(instances);
      if (!anyInstanceVisible(instances)) scheduleReleaseIfNoVisible();
      else cancelScheduledRelease();
    }
    function removeInstance() {
      const instances = readInstances().filter(i => i.id !== instanceId);
      writeInstances(instances);
      if (!anyInstanceVisible(instances)) scheduleReleaseIfNoVisible();
    }
    function scheduleReleaseIfNoVisible() {
      cancelScheduledRelease();
      const instances = readInstances();
      if (anyInstanceVisible(instances)) return;
      releaseTimer = setTimeout(() => {
        const current = readInstances();
        if (!anyInstanceVisible(current)) {
          try { releaseCachedNotifications(); } catch (e) { console.warn(e); }
        }
        releaseTimer = null;
      }, RELEASE_DELAY);
    }
    function cancelScheduledRelease() {
      if (releaseTimer) {
        clearTimeout(releaseTimer);
        releaseTimer = null;
      }
    }

    function releaseCachedNotifications() {
      const arr = JSON.parse(localStorage.getItem(CACHE_KEY) || '[]');
      if (!arr || arr.length === 0) return;
      console.log('Releasing cached notifications:', arr);
      localStorage.removeItem(CACHE_KEY);
      arr.forEach((item, i) => {
        setTimeout(() => {
          try {
            dispatchAndShow(item.detail);
          } catch (e) {
            console.warn('Failed to dispatch cached notification', e);
          }
        }, i * 200);
      });
    }

    // coordinate releases across focus pages so switching between focus pages doesn't release
    window.addEventListener('storage', (ev) => {
      if (ev.key === INSTANCES_KEY) {
        const instances = readInstances();
        if (anyInstanceVisible(instances)) {
          cancelScheduledRelease();
        } else {
          scheduleReleaseIfNoVisible();
        }
      }
    });

    if (isOnFocusSite()) registerInstance();
    document.addEventListener('visibilitychange', () => {
      if (!isRegisteredInstance && isOnFocusSite()) registerInstance();
      if (isRegisteredInstance) updateInstanceVisibility(document.visibilityState === 'visible');
      // Release cached notifications immediately when leaving this tab
      if (document.visibilityState === 'hidden') {
        releaseCachedNotifications();
      }
    });
    window.addEventListener('beforeunload', () => {
      if (isRegisteredInstance) removeInstance();
    });

    testBtn.addEventListener('click', () => {
      // simulate the exact event and native Notification the extension test uses
      const detail = {
        type: 'basic',
        iconUrl: 'extension/icon16.png',
        title: 'Test Notification',
        message: 'This is a test.'
      };
      // ensure permission then queue or send
      if (Notification.permission === 'default') {
        Notification.requestPermission().then(() => {
          queueOrSendNotification(detail);
        });
      } else {
        queueOrSendNotification(detail);
      }
    });

    function startStopwatch() {
      startTime = Date.now();
      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const min = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const sec = String(elapsed % 60).padStart(2, '0');
        document.getElementById('timer').textContent = `${min}:${sec}`;

        // Simulate notifications at specific times (only once per timestamp)
        if (notificationTimes.includes(elapsed) && !notifiedAt.has(elapsed)) {
          notifiedAt.add(elapsed);
          const detail = {
            type: 'basic',
            iconUrl: 'extension/icon16.png',
            title: 'Scheduled Notification',
            message: `This is a simulated notification at ${elapsed} seconds.`
          };
          queueOrSendNotification(detail);
        }
      }, 1000);
    }
    function stopStopwatch() {
      clearInterval(timerInterval);
    }

    // Start stopwatch on load
    if (Notification.permission === 'default' && isExtensionEnabled()) {
      Notification.requestPermission();
    }
    startStopwatch();
  </script>
</body>
</html>