<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Word Search - Programming</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #stopwatch { font-size: 1.2em; margin-bottom: 10px; }
    #grid { display: grid; grid-template-columns: repeat(12, 30px); gap: 2px; }
    .cell {
      width: 30px; height: 30px; text-align: center; vertical-align: middle;
      border: 1px solid #ccc; font-size: 18px; cursor: pointer; background: #fff;
      user-select: none;
    }
    .cell.selected { background: #b3e5fc; }
    .cell.found { background: #a5d6a7; }
    #message { margin-top: 10px; }
    #word-list-link { margin-bottom: 15px; display: inline-block; }
    #controls { margin-bottom: 12px; }
    #controls > * { margin-right: 8px; vertical-align: middle; }
  </style>
</head>
<body>
  <h2>Word Search - Programming Languages</h2>
  <div id="controls">
    <a id="word-list-link" href="wordlist1.html" target="_blank">See Word List</a>
    <label><input type="checkbox" id="extension-toggle"> Extension On</label>
    <button id="test-notif">Send Test Notification</button>
  </div>

  <div id="stopwatch">Time: <span id="timer">00:00</span></div>
  <div id="grid"></div>
  <div id="message"></div>
  <script>
    const words = ['JAVASCRIPT', 'PYTHON', 'KOTLIN', 'RUST', 'SWIFT', 'GOLANG'];
    const gridData = [
      ['T','C','I','R','P','S','A','V','A','J','L','G'],
      ['L','P','P','D','E','W','G','N','A','L','O','G'],
      ['K','O','I','F','T','H','H','O','H','T','F','U'],
      ['J','T','F','J','Z','J','B','Z','T','Q','M','E'],
      ['A','L','G','S','D','O','U','S','L','I','W','S'],
      ['H','I','F','H','K','B','G','H','A','M','S','S'],
      ['A','N','C','C','R','U','S','T','F','E','J','K'],
      ['N','X','C','V','V','A','C','J','A','B','N','M'],
      ['S','B','I','L','T','N','D','F','E','V','G','H'],
      ['D','F','G','H','J','Y','K','L','Q','W','E','R'],
      ['E','R','T','T','Y','T','U','I','O','P','A','S'],
      ['D','F','G','H','J','K','L','M','N','B','V','C']
    ];

    // --- Same game logic as your original file ---
    const gridDiv = document.getElementById('grid');
    let selectedCells = [];
    let foundWords = new Set();

    for (let row = 0; row < gridData.length; row++) {
      for (let col = 0; col < gridData[row].length; col++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.textContent = gridData[row][col];
        cell.dataset.row = row;
        cell.dataset.col = col;
        cell.addEventListener('click', () => handleCellClick(cell));
        gridDiv.appendChild(cell);
      }
    }

    function handleCellClick(cell) {
      if (cell.classList.contains('found')) return;
      cell.classList.toggle('selected');
      if (cell.classList.contains('selected')) {
        selectedCells.push(cell);
      } else {
        selectedCells = selectedCells.filter(c => c !== cell);
      }
      checkSelection();
    }

    function checkSelection() {
      const selectedWord = selectedCells.map(c => c.textContent).join('');
      const reversedWord = selectedCells.map(c => c.textContent).reverse().join('');
      if (words.includes(selectedWord)) {
        markFound(selectedWord);
      } else if (words.includes(reversedWord)) {
        markFound(reversedWord);
      }
    }

    function markFound(word) {
      selectedCells.forEach(cell => {
        cell.classList.remove('selected');
        cell.classList.add('found');
      });
      foundWords.add(word);
      selectedCells = [];
      if (foundWords.size === words.length) {
        document.getElementById('message').textContent = 'Congratulations! You found all the words!';
        stopStopwatch();
      }
    }

    // --- Same stopwatch and notification logic as your original file ---
    let startTime, timerInterval;
    const notificationTimes = [5, 10, 15, 20, 25, 30, 35, 40, 60];
    let notifiedAt = new Set();
    const TOGGLE_KEY = 'focusExtensionEnabled';
    const CACHE_KEY = 'focusExtensionCachedNotifications';
    const INSTANCES_KEY = 'focusExtensionInstances';
    const RELEASE_DELAY = 500;
    let instanceId = String(Date.now()) + '-' + Math.random().toString(36).slice(2);
    let releaseTimer = null;
    let isRegisteredInstance = false;
    const toggleEl = document.getElementById('extension-toggle');
    const testBtn = document.getElementById('test-notif');
    function isExtensionEnabled() { return localStorage.getItem(TOGGLE_KEY) === 'true'; }
    function setExtensionEnabled(v) { localStorage.setItem(TOGGLE_KEY, v ? 'true' : 'false'); toggleEl.checked = !!v; }
    toggleEl.checked = isExtensionEnabled();
    toggleEl.addEventListener('change', () => { setExtensionEnabled(toggleEl.checked); if (toggleEl.checked && Notification.permission === 'default') { Notification.requestPermission(); } });
    function dispatchAndShow(detail) { window.dispatchEvent(new CustomEvent('notify-extension', { detail })); if (Notification.permission === 'granted') { try { new Notification(detail.title, { body: detail.message, icon: detail.iconUrl }); } catch (e) { console.warn('Notification failed', e); } } }
    function cacheNotification(detail) { const arr = JSON.parse(localStorage.getItem(CACHE_KEY) || '[]'); arr.push({ detail, ts: Date.now() }); localStorage.setItem(CACHE_KEY, JSON.stringify(arr)); console.log('Notification cached', detail.title); }
    function isOnFocusSite() { return location.pathname.endsWith('wordsearch1.html') || location.pathname.endsWith('wordlist1.html'); }
    function queueOrSendNotification(detail) { if (!isExtensionEnabled()) { dispatchAndShow(detail); return; } if (isOnFocusSite() && document.visibilityState === 'visible') { cacheNotification(detail); } else { dispatchAndShow(detail); } }
    function readInstances() { try { return JSON.parse(localStorage.getItem(INSTANCES_KEY) || '[]'); } catch (e) { return []; } }
    function writeInstances(arr) { localStorage.setItem(INSTANCES_KEY, JSON.stringify(arr)); }
    function anyInstanceVisible(instances) { return (instances || readInstances()).some(i => i.visible); }
    function registerInstance() { const instances = readInstances().filter(i => i && i.id !== instanceId); instances.push({ id: instanceId, visible: document.visibilityState === 'visible', ts: Date.now() }); writeInstances(instances); isRegisteredInstance = true; if (anyInstanceVisible(instances)) cancelScheduledRelease(); }
    function updateInstanceVisibility(visible) { const instances = readInstances().filter(Boolean); const idx = instances.findIndex(i => i.id === instanceId); if (idx >= 0) { instances[idx].visible = !!visible; instances[idx].ts = Date.now(); } else { instances.push({ id: instanceId, visible: !!visible, ts: Date.now() }); isRegisteredInstance = true; } writeInstances(instances); if (!anyInstanceVisible(instances)) scheduleReleaseIfNoVisible(); else cancelScheduledRelease(); }
    function removeInstance() { const instances = readInstances().filter(i => i.id !== instanceId); writeInstances(instances); if (!anyInstanceVisible(instances)) scheduleReleaseIfNoVisible(); }
    function scheduleReleaseIfNoVisible() { cancelScheduledRelease(); const instances = readInstances(); if (anyInstanceVisible(instances)) return; releaseTimer = setTimeout(() => { const current = readInstances(); if (!anyInstanceVisible(current)) { try { releaseCachedNotifications(); } catch (e) { console.warn(e); } } releaseTimer = null; }, RELEASE_DELAY); }
    function cancelScheduledRelease() { if (releaseTimer) { clearTimeout(releaseTimer); releaseTimer = null; } }
    function releaseCachedNotifications() { const arr = JSON.parse(localStorage.getItem(CACHE_KEY) || '[]'); if (!arr || arr.length === 0) return; console.log('Releasing cached notifications:', arr); localStorage.removeItem(CACHE_KEY); arr.forEach((item, i) => { setTimeout(() => { try { dispatchAndShow(item.detail); } catch (e) { console.warn('Failed to dispatch cached notification', e); } }, i * 200); }); }
    window.addEventListener('storage', (ev) => { if (ev.key === INSTANCES_KEY) { const instances = readInstances(); if (anyInstanceVisible(instances)) { cancelScheduledRelease(); } else { scheduleReleaseIfNoVisible(); } } });
    if (isOnFocusSite()) registerInstance();
    document.addEventListener('visibilitychange', () => { if (!isRegisteredInstance && isOnFocusSite()) registerInstance(); if (isRegisteredInstance) updateInstanceVisibility(document.visibilityState === 'visible'); if (document.visibilityState === 'hidden') { releaseCachedNotifications(); } });
    window.addEventListener('beforeunload', () => { if (isRegisteredInstance) removeInstance(); });
    testBtn.addEventListener('click', () => { const detail = { type: 'basic', iconUrl: 'extension/icon16.png', title: 'Test Notification', message: 'This is a test.' }; if (Notification.permission === 'default') { Notification.requestPermission().then(() => { queueOrSendNotification(detail); }); } else { queueOrSendNotification(detail); } });
    function startStopwatch() { startTime = Date.now(); timerInterval = setInterval(() => { const elapsed = Math.floor((Date.now() - startTime) / 1000); const min = String(Math.floor(elapsed / 60)).padStart(2, '0'); const sec = String(elapsed % 60).padStart(2, '0'); document.getElementById('timer').textContent = `${min}:${sec}`; if (notificationTimes.includes(elapsed) && !notifiedAt.has(elapsed)) { notifiedAt.add(elapsed); const detail = { type: 'basic', iconUrl: 'extension/icon16.png', title: 'Scheduled Notification', message: `This is a simulated notification at ${elapsed} seconds.` }; queueOrSendNotification(detail); } }, 1000); }
    function stopStopwatch() { clearInterval(timerInterval); }
    if (Notification.permission === 'default' && isExtensionEnabled()) { Notification.requestPermission(); }
    startStopwatch();
  </script>
</body>
</html>