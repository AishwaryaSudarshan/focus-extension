<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Word Search - Programming</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start; /* Align content to the top */
      min-height: 100vh; /* Ensure full height */
      padding: 20px;
      box-sizing: border-box;
      background-color: #f4f4f4;
    }

    h2 {
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }

    #instructions {
      color: #777;
      margin-bottom: 20px;
      text-align: center;
      font-style: italic;
    }

    #stopwatch {
      font-size: 1.2em;
      margin-bottom: 10px;
      color: #555;
    }

    #grid {
      display: grid;
      grid-template-columns: repeat(12, 35px); /* Slightly larger cells */
      gap: 5px; /* Increased gap for better spacing */
      margin-bottom: 20px;
    }

    .cell {
      width: 35px;
      height: 35px;
      text-align: center;
      vertical-align: middle;
      border: 1px solid #ddd; /* Lighter border */
      font-size: 18px;
      cursor: pointer;
      background: #fff;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      transition: background-color 0.3s ease; /* Smooth transition */
    }

    .cell.selected {
      background: #bbdefb; /* Light blue */
      color: #333;
    }

    .cell.found {
      background: #c8e6c9; /* Light green */
      color: #333;
    }

    #message {
      margin-top: 20px;
      font-size: 1.1em;
      color: #4caf50; /* Green color for the message */
      text-align: center;
    }

    #word-list-link {
      margin-bottom: 15px;
      display: inline-block;
      color: #1976d2; /* Darker blue */
      text-decoration: none;
      padding: 8px 15px;
      border: 1px solid #1976d2;
      border-radius: 5px;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    #word-list-link:hover {
      background-color: #1976d2;
      color: white;
    }

    #controls {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #controls > * {
      vertical-align: middle;
    }

    #extension-toggle {
      margin-right: 5px;
    }

    button {
      background-color: #42a5f5; /* Blue button */
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #1e88e5; /* Darker blue on hover */
    }
  </style>
</head>
<body>
  <h2>Word Search - Programming Languages</h2>
  <div id="instructions">Find the words horizontally (left to right) or vertically (top to bottom).</div>
  <div id="controls">
    <a id="word-list-link" href="wordlist1.html" target="_blank">See Word List</a>
    <label><input type="checkbox" id="extension-toggle"> Extension On</label>
    <button id="test-notif">Send Test Notification</button>
  </div>

  <div id="stopwatch">Time: <span id="timer">00:00</span></div>
  <div id="grid"></div>
  <div id="message"></div>
  <script>
    const words = ['JAVASCRIPT', 'PYTHON', 'KOTLIN', 'RUST', 'SWIFT', 'GOLANG'];
    const gridData = [
      ['T','C','I','R','P','S','A','V','A','J','L','G'],
      ['L','P','P','D','E','W','G','N','A','L','O','G'],
      ['K','O','I','F','T','H','H','O','H','T','F','U'],
      ['J','T','F','J','Z','J','B','Z','T','Q','M','E'],
      ['A','L','G','S','D','O','U','S','L','I','W','S'],
      ['H','I','F','H','K','B','G','H','A','M','S','S'],
      ['A','N','C','C','R','U','S','T','F','E','J','K'],
      ['N','X','C','V','V','A','C','J','A','B','N','M'],
      ['S','B','I','L','T','N','D','F','E','V','G','H'],
      ['D','F','G','H','J','Y','K','L','Q','W','E','R'],
      ['E','R','T','T','Y','T','U','I','O','P','A','S'],
      ['D','F','G','H','J','K','L','M','N','B','V','C']
    ];

    // --- Same game logic as your original file ---
    const gridDiv = document.getElementById('grid');
    let selectedCells = [];
    let foundWords = new Set();

    for (let row = 0; row < gridData.length; row++) {
      for (let col = 0; col < gridData[row].length; col++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.textContent = gridData[row][col];
        cell.dataset.row = row;
        cell.dataset.col = col;
        cell.addEventListener('click', () => handleCellClick(cell));
        gridDiv.appendChild(cell);
      }
    }

    function handleCellClick(cell) {
      if (cell.classList.contains('found')) return;
      cell.classList.toggle('selected');
      if (cell.classList.contains('selected')) {
        selectedCells.push(cell);
      } else {
        selectedCells = selectedCells.filter(c => c !== cell);
      }
      checkSelection();
    }

    function checkSelection() {
      if (selectedCells.length < 2) return;

      const startRow = parseInt(selectedCells[0].dataset.row);
      const startCol = parseInt(selectedCells[0].dataset.col);
      const endRow = parseInt(selectedCells[selectedCells.length - 1].dataset.row);
      const endCol = parseInt(selectedCells[selectedCells.length - 1].dataset.col);

      let valid = false;
      let selectedWord = '';

      // Check horizontal (left to right)
      if (startRow === endRow && endCol > startCol) {
        valid = true;
        for (let i = 0; i < selectedCells.length; i++) {
          const cell = selectedCells[i];
          if (parseInt(cell.dataset.row) !== startRow || parseInt(cell.dataset.col) !== startCol + i) {
            valid = false;
            break;
          }
          selectedWord += cell.textContent;
        }
      }

      // Check vertical (top to bottom)
      if (startCol === endCol && endRow > startRow) {
        valid = true;
        for (let i = 0; i < selectedCells.length; i++) {
          const cell = selectedCells[i];
          if (parseInt(cell.dataset.col) !== startCol || parseInt(cell.dataset.row) !== startRow + i) {
            valid = false;
            break;
          }
          selectedWord += cell.textContent;
        }
      }

      if (valid) {
        if (words.includes(selectedWord)) {
          markFound(selectedWord);
        } else {
          clearSelection();
        }
      } else {
        clearSelection();
      }
    }

    function clearSelection() {
      selectedCells.forEach(cell => cell.classList.remove('selected'));
      selectedCells = [];
    }

    function markFound(word) {
      selectedCells.forEach(cell => {
        cell.classList.remove('selected');
        cell.classList.add('found');
      });
      foundWords.add(word);
      selectedCells = [];
      if (foundWords.size === words.length) {
        document.getElementById('message').textContent = 'Congratulations! You found all the words!';
        stopStopwatch();
      }
    }

    // --- Same stopwatch and notification logic as your original file ---
    let startTime, timerInterval;
    const notificationTimes = [5, 10, 15, 20, 25, 30, 35, 40, 60];
    let notifiedAt = new Set();
    const TOGGLE_KEY = 'focusExtensionEnabled';
    const CACHE_KEY = 'focusExtensionCachedNotifications';
    const INSTANCES_KEY = 'focusExtensionInstances';
    const RELEASE_DELAY = 500;
    let instanceId = String(Date.now()) + '-' + Math.random().toString(36).slice(2);
    let releaseTimer = null;
    let isRegisteredInstance = false;
    const toggleEl = document.getElementById('extension-toggle');
    const testBtn = document.getElementById('test-notif');
    function isExtensionEnabled() { return localStorage.getItem(TOGGLE_KEY) === 'true'; }
    function setExtensionEnabled(v) { localStorage.setItem(TOGGLE_KEY, v ? 'true' : 'false'); toggleEl.checked = !!v; }
    toggleEl.checked = isExtensionEnabled();
    toggleEl.addEventListener('change', () => { setExtensionEnabled(toggleEl.checked); if (toggleEl.checked && Notification.permission === 'default') { Notification.requestPermission(); } });
    function dispatchAndShow(detail) { window.dispatchEvent(new CustomEvent('notify-extension', { detail })); if (Notification.permission === 'granted') { try { new Notification(detail.title, { body: detail.message, icon: detail.iconUrl }); } catch (e) { console.warn('Notification failed', e); } } }
    function cacheNotification(detail) { const arr = JSON.parse(localStorage.getItem(CACHE_KEY) || '[]'); arr.push({ detail, ts: Date.now() }); localStorage.setItem(CACHE_KEY, JSON.stringify(arr)); console.log('Notification cached', detail.title); }
    function isOnFocusSite() { return location.pathname.endsWith('wordsearch1.html') || location.pathname.endsWith('wordlist1.html'); }
    function queueOrSendNotification(detail) { if (!isExtensionEnabled()) { dispatchAndShow(detail); return; } if (isOnFocusSite() && document.visibilityState === 'visible') { cacheNotification(detail); } else { dispatchAndShow(detail); } }
    function readInstances() { try { return JSON.parse(localStorage.getItem(INSTANCES_KEY) || '[]'); } catch (e) { return []; } }
    function writeInstances(arr) { localStorage.setItem(INSTANCES_KEY, JSON.stringify(arr)); }
    function anyInstanceVisible(instances) { return (instances || readInstances()).some(i => i.visible); }
    function registerInstance() { const instances = readInstances().filter(i => i && i.id !== instanceId); instances.push({ id: instanceId, visible: document.visibilityState === 'visible', ts: Date.now() }); writeInstances(instances); isRegisteredInstance = true; if (anyInstanceVisible(instances)) cancelScheduledRelease(); }
    function updateInstanceVisibility(visible) { const instances = readInstances().filter(Boolean); const idx = instances.findIndex(i => i.id === instanceId); if (idx >= 0) { instances[idx].visible = !!visible; instances[idx].ts = Date.now(); } else { instances.push({ id: instanceId, visible: !!visible, ts: Date.now() }); isRegisteredInstance = true; } writeInstances(instances); if (!anyInstanceVisible(instances)) scheduleReleaseIfNoVisible(); else cancelScheduledRelease(); }
    function removeInstance() { const instances = readInstances().filter(i => i.id !== instanceId); writeInstances(instances); if (!anyInstanceVisible(instances)) scheduleReleaseIfNoVisible(); }
    function scheduleReleaseIfNoVisible() { cancelScheduledRelease(); const instances = readInstances(); if (anyInstanceVisible(instances)) return; releaseTimer = setTimeout(() => { const current = readInstances(); if (!anyInstanceVisible(current)) { try { releaseCachedNotifications(); } catch (e) { console.warn(e); } } releaseTimer = null; }, RELEASE_DELAY); }
    function cancelScheduledRelease() { if (releaseTimer) { clearTimeout(releaseTimer); releaseTimer = null; } }
    function releaseCachedNotifications() { const arr = JSON.parse(localStorage.getItem(CACHE_KEY) || '[]'); if (!arr || arr.length === 0) return; console.log('Releasing cached notifications:', arr); localStorage.removeItem(CACHE_KEY); arr.forEach((item, i) => { setTimeout(() => { try { dispatchAndShow(item.detail); } catch (e) { console.warn('Failed to dispatch cached notification', e); } }, i * 200); }); }
    window.addEventListener('storage', (ev) => { if (ev.key === INSTANCES_KEY) { const instances = readInstances(); if (anyInstanceVisible(instances)) { cancelScheduledRelease(); } else { scheduleReleaseIfNoVisible(); } } });
    if (isOnFocusSite()) registerInstance();
    document.addEventListener('visibilitychange', () => { if (!isRegisteredInstance && isOnFocusSite()) registerInstance(); if (isRegisteredInstance) updateInstanceVisibility(document.visibilityState === 'visible'); if (document.visibilityState === 'hidden') { releaseCachedNotifications(); } });
    window.addEventListener('beforeunload', () => { if (isRegisteredInstance) removeInstance(); });
    testBtn.addEventListener('click', () => { const detail = { type: 'basic', iconUrl: 'extension/icon16.png', title: 'Test Notification', message: 'This is a test.' }; if (Notification.permission === 'default') { Notification.requestPermission().then(() => { queueOrSendNotification(detail); }); } else { queueOrSendNotification(detail); } });
    function startStopwatch() { startTime = Date.now(); timerInterval = setInterval(() => { const elapsed = Math.floor((Date.now() - startTime) / 1000); const min = String(Math.floor(elapsed / 60)).padStart(2, '0'); const sec = String(elapsed % 60).padStart(2, '0'); document.getElementById('timer').textContent = `${min}:${sec}`; if (notificationTimes.includes(elapsed) && !notifiedAt.has(elapsed)) { notifiedAt.add(elapsed); const detail = { type: 'basic', iconUrl: 'extension/icon16.png', title: 'Scheduled Notification', message: `This is a simulated notification at ${elapsed} seconds.` }; queueOrSendNotification(detail); } }, 1000); }
    function stopStopwatch() { clearInterval(timerInterval); }
    if (Notification.permission === 'default' && isExtensionEnabled()) { Notification.requestPermission(); }
    startStopwatch();
  </script>
</body>
</html>